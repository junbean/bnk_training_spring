
Layered Architecture
레이어드 아키텍처

애플리케이션의 컴포넌트를 유사 관심사를 기준으로 레이어로 묶어 수평적으로 구성한 구조분해할당

Presentation Layer
ㄴ> 애플리케이션 최상단 계층
ㄴ> UI 혹은 API 제공
ㄴ> 프레젠테이션 게층은 별도의 비지니스 로직을 포함하고 있지 않으므로 비즈니스 계층으로 요청을 위임하고 받은 결과를
   응답하는 역할만 수행

Business Layer 
ㄴ> 애플리케이션이 제공하는 기능을 정의하고 세부 작업을 수행하는 도메인 객체를 통해 업무를 위임하는 역할

Data Access Layer
ㄴ> 데이터베이스에 접근하는 일련의 작업을 수행 

------------------------------------------
레이어드 아키텍처 기반 설계는 다음과 같은 특징을 갖는다.
ㄴ> 각 레이어는 가장 가까운 하위 레이어의 의존성을 주입받는다.
ㄴ> 각 레이어는 관심사에 따라 묶여 있으며, 다른 레이어의 역할을 침범하지 않는다.
   ㄴ> 각 컴포넌트의 역할이 명확하므로 코드의 가독성과 기능 구현에 유리하다.
   ㄴ> 코드의 확장성도 좋아진다.
ㄴ> 각 레이어가 독립적으로 작성되면 다른 레이어와의 의존성을 낮춰 단위 테스트에 용이하다.

-----------------------------------------
스프링 레이어드 아키텍처
Spring MVC는 Model-view-Controller의 구조로 View 와 Controller는 프레젠테이션 계층이며,
Model은 비즈니스와 데이터접근 계층의 영역으로 구분할 수 있다.
비즈니스 계층에 서비스를 배치해 Entity 와 같은 도메인 객체의 비즈니스 로직을 조합하도록 하고
데이터 접근 계층에는 DAO (String Data JPA에서는 Repository)를 배치해 도메인으로 관리한다 . 

프레젠테이션 계층
ㄴ> 클라이언트와의 접점이 된다.
ㄴ> 클라이언트로부터 데이터와 함께 요청을 받고 처리 결과를 응답으로 전달하는 역할을 수행
ㄴ> 유저 인터페이스 ( User Interface) 계층이라고도 함

비즈니스 계층 
ㄴ> 서비스(Service) 게층이라고도 함.
ㄴ> 핵심 비즈니스 로직을 구현하는 영역임.
ㄴ> 트랜잭션 처리나 유효성 검사 등의 작업 수행

데이터 접근 계층
ㄴ> 영속 (Persistence) 계층이라고도 함.
ㄴ> 데이터베이스에 접근해야 하는 작업을 수행.
ㄴ> 



//===========================================================
REST API

REST?
Representational StateTransfer의 약자로 분산 하이퍼미디어 시스템 아키텍처의 한 형식
주고받는 자원에 이름을 규정하고 URL에 며시해 HTTP 메서드(GET, POST, PUT, DELETE)를 통해 해당
자원의 상태를 주고받는 것을 의미한다

API
Application Programming Interface의 약자로, 애플리케이션에서 제공하는 인터페이스를 의미한다
aPI를 통해 서버 또는 프로그램 사이를 연결할 수 있다

REST API - REST 아키텍처를 따르는 시스템/애플리케이션 인터페이스
REST 아키텍처를 구현하는 웹서비스를 'RESTful하다'라고 표현한다

REST의 특징
1. 유니폼 인터페이스
	- 일관된 인터페이스를 의미함
	- REST 서버는 HTTP표준 전송 규약을 따르기 때문에 어떤 언어로 만들어졌느냐와 상관없이 플랫폼 및 기술에 
	  종속되지 않고 타인이, 플랫폼, 기술 등과 호환해 사용할 수 있다는 것을 의미함
2. 무상태성
	- Stateless
	- 무상태성이란 서버에 상태 정보를 따로 보관하거나 관리하지 않는다는 의미임
	- 서버는 클라이언트가 보낸 요청에 대해 세션이나 쿠키 정보를 별도로 보관하지 않음
	- 따라서 한 클라이언트가 여러 요청을 보내든 여러 클라이언트가 각각 하나의 요청을 보내든 개별적으로 처리함
	- 이렇게 구성된 서비스는 서버가 불필요한 정보를 관리하지 않으므로 비즈니스 로직의 자유도가 높고 설계가 단순함
3. 캐시 가능성
	- 캐싱이 가능한 경우 클라이언트에서 캐시에 저장해두고 같은 요청에 대해서는 해당 데이터를 가져다 사용한다
	- 이로써 서버의 트랜잭션 부하가 줄어 효율적이며 사용자 입장에서 성능이 개선된다

4. 클라이언트 - 서버 아키텍처
	- REST 서버는 API를 제공하고 클라이언트는 사용자 정보를 관리하는 구조로 분리해 설계한다
	- 이 구성은 서로에 대한 의존성을 낮추는 기능을 한다

//========================================================================
REST의 URL설계 규칙
1. URL의 마지막에는 "/"을 포함하지 않는다
	- 옳은 예 : http://localhost.com/product 
	- 잘못된 예 : http://localhost.com/product/

2. 언더바(_)는 사용하지 않는다, 대신 하이픈(-)을 사용한다
	- 하이픈은 리소스의 이름이 길어지면 사용한다
	- 옳은 예 : http://localhost.com/provider-company-name
	- 잘못된 예 : http://localhost.com/provider_company_name

3. URL에는 행위(동사)가 아닌 결과(명사)를 포함한다
	- 옳은 예 : http://localhost.com/product/123
	- 잘못된 예 : http://localhost.com/delete-product/1234
	- 행위는 HTTP메서드로 표현한다

4. URL은 소문자로 작성해야 한다
	- 리소스 경로는 대문자 사용을 피하도록 하자

5. 파일의 확장자는 URL에 포함하지 않는다
	- HTTP에서 제공하는 Accept헤더를 사용하도록 하자




//===========================================================





DispatcherServlet으로 요청이 들어오면 DispatcherServlet은
**핸들러 매핑(Handler Mapping)**을 통해 요청 URI에 매핑된 핸들러를 탐색한다.
여기서 핸들러는 **컨트롤러(Controller)**를 의미한다.

그리고 핸들러 어댑터로 컨트롤러를 호출한다.

핸들러 어댑터에 컨트롤러의 응답이 들어오면 ModelAndView로 응답을 가공해 반환한다.

뷰 형식으로 리턴하는 컨트롤러를 사용할 때는
**뷰 리졸버(View Resolver)**를 통해 **뷰(view)**를 받아 리턴한다.

// ===================================================

클라이언트가 요청을 보내면 DispatcherServlet이 가장 먼저 받음.

HandlerMapping이 어떤 Controller가 처리할지 판단함.

해당 컨트롤러를 실행하려면 방식이 다양하므로, HandlerAdapter가 중간에서 연결 역할을 함.

컨트롤러는 비즈니스 로직 처리 후 ModelAndView를 반환함.

ViewResolver는 어떤 뷰(JSP 등)로 렌더링할지 결정함.

View에서 최종 HTML을 만들어서 클라이언트에게 전달함.


//=====================================================

[클라이언트 요청]
        ↓
[서블릿 컨테이너 (Tomcat 등)]
        ↓
[DispatcherServlet]
        ↓
[HandlerMapping] ← 어떤 컨트롤러를 호출할지 찾음
        ↓
[HandlerAdapter] ← 컨트롤러 실행을 도와주는 어댑터
        ↓
[Controller] ← 실제 로직 실행, ModelAndView 리턴
        ↓
[ViewResolver] ← 어떤 JSP/HTML로 보여줄지 결정
        ↓
[View] ← 최종 뷰 렌더링 (예: JSP)
        ↓
[클라이언트에게 응답]
